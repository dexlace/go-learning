package main

import "fmt"

// 我们可以使用channel在多个goroutine之间传递消息
// go提倡通过通信来共享内存
// 而不是通过共享内存来实现通信

func main() {
	/**************************第12行 管道的声明************************************/
	fmt.Println("/**************************第12行 管道的声明************************************/")
	// 1.声明一个传递整形的通道
	var ch1 chan int
	// 声明一个传递布尔类型的管道
	var ch2 chan bool
	// 声明一个传递整形切片的通道
	var ch3 chan []int

	// channel是一种引用类型 必须初始化后才能使用
	// 所以下面打印的是nil
	fmt.Println(ch1)

	/***********************第22行 为管道分配空间******************************/

	fmt.Println("/**************************第27行 为管道分配空间************************************/")
	// 2.为管道分配空间
	ch1 = make(chan int)
	// 注意这里打印的是地址  channel是引用类型
	fmt.Println(ch1)

	// 创建一个能够存储10个bool类型的数据管道
	ch2 = make(chan bool, 10)
	fmt.Println(ch2)

	// 创建一个能够存储3个[]int切片类型的管道
	ch3 = make(chan []int, 3)
	fmt.Println(ch3)

	fmt.Println("/**************************第41行 管道的操作************************************/")
	/***********************第36行 管道的操作******************************/
	// 3.channel操作
	// 3.1 发送
	ch4 := make(chan int, 3)
	ch4 <- 10
	// 3.2 接收
	x := <-ch4
	fmt.Println(x)

	/***********************第37行 管道的完整示例******************************/
	fmt.Println("/**************************第52行 管道的完整示例************************************/")
	ch5 := make(chan int, 3)
	ch5 <- 9
	ch5 <- 90
	ch5 <- 900

	// 从管道中获取内容
	a := <-ch5
	fmt.Println("打印出管道的值：", a)
	fmt.Println("打印出管道的值：", <-ch5)
	// 管道的值、容量、长度
	fmt.Printf("地址：%v 容量：%v 长度：%v \n", ch5, cap(ch5), len(ch5))
	fmt.Println("打印出管道的值：", <-ch5)

	// 管道的值、容量、长度
	fmt.Printf("地址：%v 容量：%v 长度：%v \n", ch5, cap(ch5), len(ch5))
	// 所以管道的长度是里面存的值的个数

	// 管道的类型
	fmt.Printf("%T \n", ch5)

	fmt.Println("/**************************第73行 管道阻塞************************************/")
	// <-ch5 // 会panic 下面的代码无法执行  因为没有数据了
	fmt.Println("sdsdsdsds")

	ch5 <- 10
	ch5 <- 10
	ch5 <- 10
	//ch5<-10 管道满了 继续存 同样阻塞  会panic

	fmt.Println("/**************************第82行 for range与管道************************************/")
	fmt.Println("/**************************第82行 for range遍历管道之前一定需要先关闭管道************************************/")
	// 创建管道
	ch := make(chan int, 10)
	// 循环写入值
	for i := 0; i < 10; i++ {
		ch <- i
	}
	// 关闭管道  使用for range遍历的时候，一定在之前需要先关闭管道
	close(ch)

	// for range循环遍历管道的值(管道没有key)
	for value := range ch {
		fmt.Println(value)
	}

	fmt.Println("/**************************第96行 for i遍历管道不需要关闭管道*/")
	// 创建管道
	ch111 := make(chan int, 10)
	// 循环写入值
	for i := 10; i < 19; i++ {
		ch111 <- i
	}

	for i := 10; i < 19; i++ {
		fmt.Println(<-ch111)
	}

	fmt.Println("/**************************第108行 单向管道*/")
	// 有时候我们会将管道作为参数在多个任务函数间传递，
	// 很多时候我们在不同的任务函数中，使用管道都会对其进行限制，
	// 比如限制管道在函数中只能发送或者只能接受
	// 定义一种可读可写的管道
	var ch23 = make(chan int, 2)
	ch23 <- 10
	<- ch23

	// 管道声明为只写管道，只能够写入，不能读
	var ch33 = make(chan<- int, 2)
	ch33 <- 10

	// 声明一个只读管道
	var ch43 = make(<-chan int, 2)
	<- ch43


}
